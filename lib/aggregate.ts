import { z } from "zod";

// A generic type for any domain event
interface IDomainEvent {
	aggregateId: string;
	timestamp: Date;
}

// The configuration object that a developer provides
export interface AggregateConfig<TProps, TActions extends Record<string, any>> {
	name: string;
	schema: z.ZodType<TProps>;
	invariants: Array<(state: TProps) => void>;
	actions: TActions;
}

/**
 * A factory function that creates a robust, behavior-rich Aggregate class.
 * @param config - The declarative configuration for the aggregate.
 * @returns A class representing the configured Aggregate.
 */
export function createAggregate<
	TProps extends { id: string },
	TActions extends Record<
		string,
		(state: TProps, ...args: any[]) => { state: TProps; event?: IDomainEvent }
	>,
>(config: AggregateConfig<TProps, TActions>) {
	return class Aggregate {
		// Use # prefix for truly private fields (ES2022)
		#props: TProps;
		#pendingEvents: IDomainEvent[] = [];

		constructor(props: TProps) {
			this.#props = props;
		}

		/**
		 * The only public way to create an instance of the Aggregate.
		 * It validates the input data against the schema and checks invariants.
		 * @param data - The raw data for creating the aggregate.
		 */
		public static create(data: unknown) {
			// 1. Validate the input against the schema
			const props = config.schema.parse(data);

			// 2. Check invariants on initial state
			for (const invariant of config.invariants) {
				invariant(props);
			}

			// 3. Return a new instance
			return new Aggregate(props);
		}

		/**
		 * Provides access to a frozen copy of the aggregate's state.
		 * This ensures the internal state cannot be mutated from outside.
		 */
		public get state(): Readonly<TProps> {
			return Object.freeze({ ...this.#props });
		}

		/**
		 * Returns all domain events that have been generated by actions
		 * but not yet consumed. After calling this, the internal event queue is cleared.
		 */
		public getPendingEvents(): IDomainEvent[] {
			const events = [...this.#pendingEvents];
			this.#pendingEvents = [];
			return events;
		}

		/**
		 * An object containing all the defined actions for this aggregate.
		 * These are the only ways to mutate the aggregate's state.
		 */
		public get actions(): {
			[K in keyof TActions]: (
				...args: TActions[K] extends (state: TProps, ...args: infer P) => any
					? P
					: never
			) => void;
		} {
			const actionMethods: any = {};

			for (const [actionName, actionFn] of Object.entries(config.actions)) {
				actionMethods[actionName] = (...args: any[]) => {
					// 1. Apply the action function to get the new state and optional event
					const result = actionFn(this.#props, ...args);

					// 2. Check invariants on the new state
					for (const invariant of config.invariants) {
						invariant(result.state);
					}

					// 3. Update the internal state
					this.#props = result.state;

					// 4. If an event was generated, add it to the queue
					if (result.event) {
						this.#pendingEvents.push(result.event);
					}
				};
			}

			return actionMethods;
		}
	};
}