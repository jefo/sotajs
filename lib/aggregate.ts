import { z } from "zod";
import { produce } from "immer";

// A generic type for any domain event
interface IDomainEvent {
	aggregateId: string;
	timestamp: Date;
}

// WeakMaps to store internal state
const aggregateProps = new WeakMap<any, any>();
const aggregateEvents = new WeakMap<any, any[]>();

// The configuration object that a developer provides
export interface AggregateConfig<TProps, TActions extends Record<string, any>> {
	name: string;
	schema: z.ZodType<TProps>;
	invariants: Array<(state: TProps) => void>;
	actions: TActions;
}

/**
 * A factory function that creates a robust, behavior-rich Aggregate class.
 * @param config - The declarative configuration for the aggregate.
 * @returns A class representing the configured Aggregate.
 */
export function createAggregate<
	TProps extends { id: string },
	TActions extends Record<
		string,
		(state: TProps, ...args: any[]) => { event?: IDomainEvent } | void
	>,
>(config: AggregateConfig<TProps, TActions>) {
	return class Aggregate {
		private constructor(props: TProps) {
			aggregateProps.set(this, props);
			aggregateEvents.set(this, []);
		}

		/**
		 * The only public way to create an instance of the Aggregate.
		 * It validates the input data against the schema and checks invariants.
		 * @param data - The raw data for creating the aggregate.
		 */
		public static create(data: unknown) {
			// 1. Validate the input against the schema
			const props = config.schema.parse(data);

			// 2. Check invariants on initial state
			for (const invariant of config.invariants) {
				invariant(props);
			}

			// 3. Return a new instance
			return new Aggregate(props);
		}

		/**
		 * Provides access to the aggregate's ID.
		 */
		public get id(): string {
			return aggregateProps.get(this).id;
		}

		/**
		 * Provides access to a frozen copy of the aggregate's state.
		 * This ensures the internal state cannot be mutated from outside.
		 */
		public get state(): Readonly<TProps> {
			return Object.freeze({ ...aggregateProps.get(this) });
		}

		/**
		 * Returns all domain events that have been generated by actions
		 * but not yet consumed. After calling this, the internal event queue is cleared.
		 */
		public getPendingEvents(): IDomainEvent[] {
			const events = [...(aggregateEvents.get(this) || [])];
			aggregateEvents.set(this, []);
			return events;
		}

		/**
		 * Clears the event queue without returning the events.
		 */
		public clearEvents(): void {
			aggregateEvents.set(this, []);
		}

		/**
		 * An object containing all the defined actions for this aggregate.
		 * These are the only ways to mutate the aggregate's state.
		 */
		public get actions(): {
			[K in keyof TActions]: (
				...args: TActions[K] extends (state: TProps, ...args: infer P) => any
					? P
					: never
			) => void;
		} {
			const actionMethods: any = {};

			for (const [actionName, actionFn] of Object.entries(config.actions)) {
				actionMethods[actionName] = (...args: any[]) => {
					const currentState = aggregateProps.get(this);

					// Use Immer's produce to handle state updates immutably
					const nextState = produce(currentState, (draft: TProps) => {
						const result = actionFn(draft, ...args);

						// If an event was generated, add it to the queue
						if (result && result.event) {
							const events = aggregateEvents.get(this) || [];
							events.push(result.event);
							aggregateEvents.set(this, events);
						}
					});

					// Check invariants on the new state
					for (const invariant of config.invariants) {
						invariant(nextState);
					}

					// Update the internal state
					aggregateProps.set(this, nextState);
				};
			}

			return actionMethods;
		}
	};
}
