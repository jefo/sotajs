# Спецификация документации SotaJS

Этот документ описывает структуру и содержание итогового файла `docs2/README.md`.

---

**Название:** SotaJS: Руководство по архитектуре и разработке

### 1. Введение: Философия фреймворка

- Краткое описание SotaJS как фреймворка, ориентированного на бизнес-логику.
- Упоминание ключевых принципов: функциональный подход, явные зависимости, тестируемость.
- Отказ от "магии" в пользу прозрачности.

### 2. Ключевая терминология

- Глоссарий основных понятий фреймворка:
    - **Агрегат (Aggregate):** Транзакционная граница, группирующая связанные объекты и обеспечивающая их целостность.
    - **Сущность (Entity):** Объект с уникальным идентификатором и жизненным циклом.
    - **Объект-значение (Value Object):** Неизменяемый объект, определяемый своими атрибутами.
    - **Use Case:** Атомарная операция бизнес-логики, оркестрирующая доменные модели и порты.
    - **Порт (Port):** Абстрактный контракт (интерфейс) для взаимодействия с внешней инфраструктурой.
    - **Адаптер (Adapter):** Конкретная реализация порта (например, для работы с базой данных или API).
    - **DTO (Data Transfer Object):** Простой объект для передачи данных между слоями.

### 3. Основные строительные блоки

- **3.1. Агрегаты: ядро бизнес-логики**
    - Описание фабрики `createAggregate`.
    - Разбор её компонентов: `schema` (zod), `invariants` (бизнес-правила), `actions` (изменения состояния).
    - Пример кода: создание и использование агрегата `Order`.

- **3.2. Use Cases и Порты: оркестрация и зависимости**
    - Описание Use Case как асинхронной функции.
    - Механизм внедрения зависимостей через хук `usePort`.
    - Соглашение об использовании DTO в качестве единственного аргумента для портов.
    - Пример кода: `createOrderUseCase`, демонстрирующий валидацию ввода, вызов доменной логики и взаимодействие с портами.

- **3.3. Внедрение зависимостей: связующее звено**
    - Детальное описание полного цикла DI: `createPort`, `setPortAdapter`, `usePort`, `resetDI`.
    - Пример, ориентированный на тестирование: определение порта, создание мок-адаптера для теста и реального адаптера.

- **3.4. Сущности и Объекты-значения**
    - Краткие примеры использования фабрик `createEntity` и `createValueObject`.
    - Акцент на ключевых различиях: наличие ID и изменяемость/неизменяемость.

### 4. Процесс разработки в Sota

- Пошаговое руководство по "inside-out" подходу.
- **Шаг 1:** Определение контракта (Use Case, порты, DTO).
- **Шаг 2:** Реализация доменной логики (Агрегаты).
- **Шаг 3:** Изолированное тестирование (с мок-адаптерами).
- **Шаг 4:** Реализация инфраструктурных адаптеров.
- **Шаг 5:** Связывание адаптеров в точке композиции (Composition Root).
- Иллюстрация каждого шага на сквозном примере `createPostUseCase`.

### 5. Архитектурные принципы и лучшие практики

- **5.1. Моделирование отношений между Агрегатами**
    - Правило №1: Ссылки на другие агрегаты — **только по ID**.
    - Правило №2: Одна транзакция — один изменяемый агрегат.

- **5.2. Проектирование Портов (Принцип CQRS)**
    - Порты для записи (команды) должны принимать на вход полный агрегат для гарантии проверки инвариантов.
    - Порты для чтения (запросы) могут возвращать оптимизированные DTO для конкретных нужд.

- **5.3. Как избежать распространенных ошибок**
    - Краткое объяснение проблемы "Божественного Агрегата" (God Aggregate) и рекомендации по созданию небольших, сфокусированных агрегатов.
